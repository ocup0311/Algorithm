# 筆記方向 ===================================================================================
1. 查演算法的各種使用時機
2. 附圖解
3. pseudo code
4. 簡單文字描述
5. Big O

# Sorting ==================================================================================
  Bubble, Insertion, Selection, Merge, Heap, Quick

    ; not so efficient O(n^2)---------------------------------------------
    ＊Bubble Sort O(n^2)
    "Bubble sort compares adjacent elements and swaps them if they are in the wrong order."
    "目前幾乎沒地方在使用。"
    "兩兩互比, 小的左移"
    "[3,7,4,1,9,2] --> [3,7,4,1,2,9] --> [3,7,1,4,2,9] --> [3,1,7,4,2,9] --> [1,3,7,4,2,9] --> [1,3,7,2,4,9] --> [1,3,2,7,4,9] --> [1,2,3,7,4,9] --> [1,2,3,4,7,9]"
        worst case performance: O(n^2)
        best case performance: O(n^2) -- with break point --> O(n)
        average performance: O(n^2)

    ＊Insertion Sort 
    "Keeping inserting a new value into a sorted array. Insert it to the correct spot sot the sorted array remains sorted."
    "效率比 Bubble Sort 略好"
    "照順序一個個, 往左比過去, 一個數一次比到位"
    "[3,7,4,1,9,2] --> [3,7,4,1,9,2] --> [3,4,7,1,9,2] --> [3,4,1,7,9,2] --> [3,1,4,7,9,2] --> [1,3,4,7,9,2] --> [1,3,4,7,9,2] --> [1,3,4,7,2,9] --> [1,3,4,2,7,9] --> [1,3,2,4,7,9] --> [1,2,3,4,7,9]"
        worst case performance: O(n^2)
        best case performance: O(n)
        average performance: O(n^2)    

    ＊Selection Sort
    "The principle of selection sort is - select the smallest value in unsorted array, and then swap it with the left most value in this unsorted array."
    "找到最小值, 移去最左邊"
        worst case performance: O(n^2)
        best case performance: O(n^2)
        average performance: O(n^2)    

    ; not so efficient O(n^2)---------------------------------------------

    ; Comparison Model 中, 目前最快排列 O(nlogn) ---------------------------------------------
    ＊Merge Sort
    "Take advantage of the fact that combining two sorted arrays has O(n) time complexity, using the pointer skill."
    "divide and conquer (分而治之)" --> 通常會跟 recursion 併用
    "空間複雜度較高 <-- 需一直建立 array"
    "[3,7,4,1,9,2] --> [3],[7],[4],[1],[9],[2] --> [3,7],[1,4],[2,9] --> [1,3,4,7],[2,9] --> [1,2,3,4,7,9]"

        # Big O
        切片 --> O(nlogn)
        每層合併為 O(n) 共 logn(base2) 層 --> O(nlogn)      +
        ---------------------------------------------------
        O(nlogn) + O(nlogn) ==> O(nlogn)       

        ; --------------------------------------------
        ; 原本想說直接一次切完, 再 merge: 
        ; 切片為 O(n),  合併為 O(nlogn)
        ; => O(n) + O(nlogn) =>  O(nlogn)
        ; 
        ; 實際寫之後, 覺得這樣不太可行 & 差別不大, 直接跟著 recursion 即可, 變成: 
        ; 切片為 O(nlogn),  合併為 O(nlogn)
        ; => O(nlogn) + O(nlogn) =>  O(nlogn)
        ; 最後還是 O(nlogn)
        ; ---------------------------------------------
        
        worst case performance: O(nlogn)
        best case performance: O(nlogn)
        average performance: O(nlogn)

    ＊Heap Sort
    "array --> Complete Binary Tree --> Max Heap Tree --> array"
        
        # 步驟
        ; ---------------------------------------------
        ; 1. 從最底層開始把大的往上換
        ; 2. 當上層有換過時, 需再次檢查他的下層, 直到底層
        ; 3. root 與 last 互換, HeapSize - 1
        ; 4. 重複 2 & 3 直到 HeapSize 歸零
        ; ---------------------------------------------


        # Big O
        建樹 --> O(n)
        排列 --> O(nlogn)   +
        ----------------------------
        O(n) + O(nlogn) ==> O(nlogn)

        worst case performance: O(nlogn)
        best case performance: O(nlogn) [or O(n)  <--  [1,1,1,1,1]]
        average performance: O(nlogn)

    ＊Quick Sort
    
        Partition
        "The idea of partition algorithm is to divide the array into 2 parts. Either part is a sorted array, but the element in the middle is sorted(we found its correct final spot)"
        "把 last 當作 pivot --> 比 pivot 小的右移到小區, 如右示意 (小區-大區-pivot) --> 最後把大區第一個跟 pivot 交換 (小區-pivot-大區)"
        "[3,7,2,1,9,4] --> [3,7,2,1,9,4] --> [3,2,7,1,9,4] --> [3,2,1,7,9,4] --> [3,2,1,7,9,4] --> [3,2,1,4,9,7]"
            ==> [3,2,1,4,9,7] ==> 如上跑一輪後只有 4 的位置排好
        
        # 步驟
        ; ---------------------------------------------
        ; 1. 不斷對每個 part 做 Partition
        ; ---------------------------------------------

        worst case performance: O(n^2)
        best case performance: O(nlogn)
        average performance: O(nlogn)

        與 Merge Sort, Heap Sort 比較:
            優勢:
                因為過程中省去建立許多 array, 空間複雜度相對小很多？
                省去建立 array 所花費時間, 在一般的情況下, 時間也能較快？
            劣勢:
                worst case performance: O(n^2)
                worst case 時可能會 stack overflow
        


    ; Comparison Model 中, 目前最快排列 O(nlogn) ---------------------------------------------


"Lower bounds of sorting is Ω(nlogn)"
        sorting 得到的結果畫成 Decision Tree, 
        最後所有可能的 leaf 長相如下範例,
        如同將所有 item 做排列(permutation),
        --> 總共有 n! 個 leaf 
        --> log(n!)
        --> Ω(nlogn), O(nlongn)

        A[0] ≤ A[5] ≤ A[4] ≤ A[2] ≤ A[1] ≤ A[3]  
         6      5      4      3      2      1       <-- 排列可能數量
         n  +  n-1   +   ...     ...     +  1       <-- n!



; ＊ 找時間把 O, Ω, Θ 算法再認真看一遍

