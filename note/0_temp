# 筆記方向 ===================================================================================
1. 查演算法的各種使用時機
2. 附圖解
3. pseudo code
4. 簡單文字描述
5. Big O
6. 找機會轉成 Markdown
7. （Ｑ？） still need to find the anwer


# 重看過往 ====================================================================================
＊ 整理多層 object --> 淮: 用 BFS
＊ old case study: idsToChildren
＊ 找時間把 O, Ω, Θ 算法再認真看一遍


# Brute-force (暴力破解)

# Backtracking (回朔法)
    "一種暴力破解法(Brute-force attack), 暴力破解時, 記錄下排除掉的候選人, 再次遇到時就直接略過他, 回朔到上一步繼續處理其他候選人。"
    
    # code practice:
        permutation_3item
        N Queens Puzzle

# Branch-and-Bound (分支定界)
"以二元樹分支 (選取與否 0/1 ), 不斷找出上下界線, 排除低於下界線的分支, 優先處理最高上界的分支"

    # code practice:
    0/1 Knapsack Problem
        # 解析 ------------------------------------------------
        item of input:{
          cost: "物品所需花費 (重量)"
          profit: "物品利潤 (performance)"
          cp: "profit / cost"
        }

        global:{
          maxCost: "背包最大承重, 最大可承受花費 (limit)"
          lowerBound_tree: "目前整棵樹的 lowerBound"
        }

        node of tree:{
          cost: "此 Branch 已確定 cost"
          profit: "此 Branch 已確定 profit"
          lowerBound: "以 cp 排序選取, 取得 < maxCost 的 profit"
          upperBound: "以 Fractional Knapsack Problem 計算"
        }

        1. 優先尋找最高 maxProfit node 的 Branch 
        2. 若 upperBound < lowerBound_tree  --> 排除此 Branch
        3. 若 cost > maxCost               --> 排除此 Branch
        # 解析 ------------------------------------------------
