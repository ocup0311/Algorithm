# 筆記方向 ===================================================
1. 查演算法的各種使用時機
2. 附圖解
3. pseudo code
4. 簡單文字描述
5. Big O



# Big O Notation ============================================
; https://www.khanacademy.org/computing/computer-science/algorithms/asymptotic-notation/a/asymptotic-notation
; https://cs.stackexchange.com/questions/23068/how-do-o-and-%CE%A9-relate-to-worst-and-best-case

以「複雜度」取代「計時」的方式衡量演算法的原因: 
    1. Same computer gets different runtime for the same task.
    2. Different computing power machine gives different run time for the same task.

Big O: "upper bound"
Big Omega (Ω): "lower bound"
Big Theta (Θ): "average bound (asymptotically tight bound?)"

Q:為何主要用 Big O？
    "一般比較在意 the worst-case 的 upper bound"
    "比起其他兩個較易計算"

網路解釋範例: 
    ; ---------------------------------------------------------
    Contrive(n)
    1. if n is 0 then do something Θ(n^3)
    2. else if n is even then
    3.    flip a coin
    4.    if heads, do something Θ(n)
    5.    else if tails, do something Θ(n^2)
    6. else if n is odd then
    7.    flip a coin
    8.    if heads, do something Θ(n^4)
    9.    else if tails, do something Θ(n^5)
    ; ----------------------------------------------------------
    "In the best case (where n is even), the runtime is Ω(n) and O(n^2), but not Θ of anything.
    In the worst case (where n is odd), the runtime is Ω(n^4) and O(n^5), but not Θ of anything.
    In the case n=0, the runtime is Θ(n^3)."



# Big O for js =================================================
; array:
; https://adrianmejia.com/data-structures-time-complexity-for-beginners-arrays-hashmaps-linked-lists-stacks-queues-tutorial/
; https://dev.to/lukocastillo/time-complexity-big-0-for-javascript-array-methods-and-examples-mlg
; https://stackoverflow.com/questions/22614237/javascript-runtime-complexity-of-array-functions
; string:
; https://stackoverflow.com/questions/47733645/what-is-the-algorithmic-complexity-of-string-slicing-practical-real-world
; https://mrale.ph/blog/2016/11/23/making-less-dart-faster.html

Object:
    insertion O(1)
    removal O(1)
    searching O(n)
    accessing O(1)

Array:
    insertion
        push O(1)
        shift O(n)
    removal
        pop O(1)
        unshift O(n)
    searching O(n)
    accessing O(1)

    sort: O(nlogn)
    slice: O(n)

String:
    slice: O(1)



# Search ==========================================================
    # Linear Search (Sequential Search) ---------------------------
    照線性順序, 找到目標｜全找完找不到

    O(n)
        worst case performance: O(n)
        best case performance: O(1)
        average performance: O(n/2)

    # Binary Search -----------------------------------------------
    需要 sorted data set

    O(logn)
        worst case performance: O(logn)
        best case performance: O(1)
        average performance: O(logn)



# Counter ========================================================

    # code practice:
    ＊Same Frequency
    "Write a function that takes two strings and check if they have the same letters.Order doesn't matter."
        by loop O(n)

    ＊intersection
    "Write a function that takes two arrays as parameters, and then return an array that is the intersection of these two arrays."
        by loop O(n^2)
        by counter O(n)

    ＊Average Pair
    "Write a function that given a sorted array of integers and a number. Find if there's any pair in the array that has average of the given number. Find all of them. There might be multiple pairs fit the condition."
        by loop O(n^2)
        by counter O(n)
        by pointer O(n) (need sorted)



# Pointer ========================================================

    # code practice:
    ＊Palindrome
    "Write a function that checks if the input string is a palindrome. Palindrome is a word that can be read forwards and backwards."
        by pointer O(n)

    ＊Subsequence promblem
    "A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. Write a function that checks if one string is a subsequence of the other string."
        by pointer O(n)



# Sliding Window =================================================
"Generally speaking, a sliding window is a sub-list that runs over an underlying collection."
input:
    array: [a, b, c, d, e, f, g] (也可是動態 array)
    size: 3

output:
    [a, b, c]
       [b, c, d]
          [c, d, e]
             [d, e, f]
                [e, f, g]


    # code practice:
    ＊Max and Min Sum
    "Write two functions that calculate the max and min sum of n consecutive numbers in an array."
        by pass whole set O(n * size)
        by pass terminal O(n)

    ＊minSubLength
    "Write a function called minSubLength which accepts two parameters, an array of positive integers and a positive integer. This function should return the minimal length of a continuous subarray - the sum of elements inside this subarray has to be greater than or equal to the positive integer parameter. If subarray not found, then return 0."
        by use maxSum O(n ^ 2)
        by pointer O(n) (每項必須為自然數)

    ＊unique letters string
    "Write a function called uniqueLettersString, which accepts a string and returns the length of the longest substring with all distinct characters."

    ＊largest product（乘積）
    "The four adjacent digits in the 1000-digit number that have the greatest product are 9x9x8x9=5832. Find the n adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?"



# Recursion ======================================================
"A function that calls itself."
"Recursion is using a data structure called 'stack'. When we are calling a function inside another function, we are on the call stack."
"Recursion is also a mathematical relation in sequences."

    # pseudo code:
        recursion(n):
            if n equal 1:
                return A1
            else:
                return recursion(n-1)

    # Big O: call x times rs() inside itslef
    ; https://stackoverflow.com/questions/13467674/determining-complexity-for-recursive-functions-big-o-notation
        rs: recursive(n-1) x: 1 --> O(n)
        rs: recursive(n-5) x: 1 --> O(n/5)
        rs: recursive(n/5) x: 1 --> O(log(n)) --base 5
        rs: recursive(n-1) x: 2 --> O(2^n) (exponential)

    # code practice:
        ＊Recursion Sequence
            O(n)

        ＊Fibonacci Sequence
        "Write a function that takes an integer N as an input and returns the Nth number in Fibonacci Sequence."
            withoutStore O(2^n)
            withStore O(n)

        ＊Array of Arrays
        "Write a function that collects all value in an array of arrays and return an array of values collected."
            O(n)



# Sorting ======================================================
  Bubble, Insertion, Selection, Merge, Heap, Quick

    ; not so efficient O(n^2)---------------------------------------------
    ＊Bubble Sort O(n^2)
    "Bubble sort compares adjacent elements and swaps them if they are in the wrong order."
    "目前幾乎沒地方在使用。"
    "兩兩互比, 小的左移"
    "[3,7,4,1,9,2] --> [3,7,4,1,2,9] --> [3,7,1,4,2,9] --> [3,1,7,4,2,9] --> [1,3,7,4,2,9] --> [1,3,7,2,4,9] --> [1,3,2,7,4,9] --> [1,2,3,7,4,9] --> [1,2,3,4,7,9]"
        worst case performance: O(n^2)
        best case performance: O(n^2) -- with break point --> O(n)
        average performance: O(n^2)

    ＊Insertion Sort 
    "Keeping inserting a new value into a sorted array. Insert it to the correct spot sot the sorted array remains sorted."
    "效率比 Bubble Sort 略好"
    "照順序一個個, 往左比過去, 一個數一次比到位"
    "[3,7,4,1,9,2] --> [3,7,4,1,9,2] --> [3,4,7,1,9,2] --> [3,4,1,7,9,2] --> [3,1,4,7,9,2] --> [1,3,4,7,9,2] --> [1,3,4,7,9,2] --> [1,3,4,7,2,9] --> [1,3,4,2,7,9] --> [1,3,2,4,7,9] --> [1,2,3,4,7,9]"
        worst case performance: O(n^2)
        best case performance: O(n)
        average performance: O(n^2)    

    ＊Selection Sort
    "The principle of selection sort is - select the smallest value in unsorted array, and then swap it with the left most value in this unsorted array."
    "找到最小值, 移去最左邊"
        worst case performance: O(n^2)
        best case performance: O(n^2)
        average performance: O(n^2)    

    ; not so efficient O(n^2)---------------------------------------------

    ; 目前最快排列 O(nlogn) ---------------------------------------------
    ＊Merge Sort
    "Take advantage of the fact that combining two sorted arrays has O(n) time complexity, using the pointer skill."
    "divide and conquer (分而治之)" --> 通常會跟 recursion 併用
    "空間複雜度較高 <-- 需一直建立 array"
    "[3,7,4,1,9,2] --> [3],[7],[4],[1],[9],[2] --> [3,7],[1,4],[2,9] --> [1,3,4,7],[2,9] --> [1,2,3,4,7,9]"

        # Big O
        切片 --> O(nlogn)
        每層合併為 O(n) 共 logn(base2) 層 --> O(nlogn)      +
        ---------------------------------------------------
        O(nlogn) + O(nlogn) ==> O(nlogn)       

        ; --------------------------------------------
        ; 原本想說直接一次切完, 再 merge: 
        ; 切片為 O(n),  合併為 O(nlogn)
        ; => O(n) + O(nlogn) =>  O(nlogn)
        ; 
        ; 實際寫之後, 覺得這樣不太可行 & 差別不大, 直接跟著 recursion 即可, 變成: 
        ; 切片為 O(nlogn),  合併為 O(nlogn)
        ; => O(nlogn) + O(nlogn) =>  O(nlogn)
        ; 最後還是 O(nlogn)
        ; ---------------------------------------------
        
        worst case performance: O(nlogn)
        best case performance: O(nlogn)
        average performance: O(nlogn)

    ＊Heap Sort
    "array --> Complete Binary Tree --> Max Heap Tree --> array"
        
        # 步驟
        ; ---------------------------------------------
        ; 1. 從最底層開始把大的往上換
        ; 2. 當上層有換過時, 需再次檢查他的下層, 直到底層
        ; 3. root 與 last 互換, HeapSize - 1
        ; 4. 重複 2 & 3 直到 HeapSize 歸零
        ; ---------------------------------------------


        # Big O
        建樹 --> O(n)
        排列 --> O(nlogn)   +
        ----------------------------
        O(n) + O(nlogn) ==> O(nlogn)

        worst case performance: O(nlogn)
        best case performance: O(nlogn)
        average performance: O(nlogn)

    ＊Quick Sort
    
        Partition
        "The idea of partition algorithm is to divide the array into 2 parts. Either part is a sorted array, but the element in the middle is sorted(we found its correct final spot)"
        "把 last 當作 pivot --> 比 pivot 小的右移到小區, 如右示意 (小區-大區-pivot) --> 最後把大區第一個跟 pivot 交換 (小區-pivot-大區)"
        "[3,7,2,1,9,4] --> [3,7,2,1,9,4] --> [3,2,7,1,9,4] --> [3,2,1,7,9,4] --> [3,2,1,7,9,4] --> [3,2,1,4,9,7]"
            ==> [3,2,1,4,9,7] ==> 如上跑一輪後只有 4 的位置排好
        
        # 步驟
        ; ---------------------------------------------
        ; 1. 不斷對每個 part 做 Partition
        ; ---------------------------------------------

        worst case performance: O(n^2)
        best case performance: O(nlogn)
        average performance: O(nlogn)

        與 Merge Sort, Heap Sort 比較:
            優勢:
                因為過程中省去建立許多 array, 空間複雜度相對小很多？
                省去建立 array 所花費時間, 在一般的情況下, 時間也能較快？
            劣勢:
                worst case performance: O(n^2)
                worst case 時可能會 stack overflow
        


    ; 目前最快排列 O(nlogn) ---------------------------------------------



# tree ======================================================
"tree is acyclic graph"

    名詞: node, edge(箭頭), root, subtree, children, parent node, leaf

    Binary Tree: "所有 node 最多兩個 children"
    Complete Binary Tree: "只有最右邊最底部為空"
    Full Binary Tree(FBT): "所有的葉子有一樣的 depth"
    Max Heap: "Complete + 所有 subtree, root 必為最大值 -(左右沒差)"



# 重看過往 ======================================================
＊ 整理多層 object --> 淮: 用 BFS
＊ old case study: idsToChildren



